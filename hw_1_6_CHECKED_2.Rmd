---
title: "hw_1_6"
author: "Ilya Sattarov"
output: html_document
---

1. Какой значение вернет следующая функция? Запишите ответ с пояснением почему, НЕ исполняя код функции.

Комментарии: 
Должно получиться 100100.
`x` во вложенной функции будет найден в функции `f1` (как ее параметр), так как будет рассматриваться как аргумент функции `f1`.
В связи с тем, что `x` будет найдено внутри функции `f1`, то за поиском не будет продолжаться на уровень выше - в global environment, т.е. `x <- 42` хоть и сохранит свое значение, но использоваться внутри формулы не будет.

```{r}
x <- 42
f1 <- function(x) {
  function() {
    x + 10e4
  }
}
f1(100)()


```
Проверьте себя, запустив данный фрагмент кода, и поясните результат.

Комментарии:

Приведенный выше пример демонстрирует лексическую область видимости (lexical scoping) в R. Так как `function()` определена внутри функции `f1(x)`, то и поиск `x` начнется в первую очередь там, где определена вложенная функция, - в `f1`.  

Особенности lexical scoping четко видно на другом примере, когда применяемая внутри функции `f1(x)` функция `f2() x + 10e4` изначально определена вне `f1(x)`.  Во втором случае, когда выполняется определенная в global environment `f2`  внутри `f1`, то результат будет иной, так как значение `x` будет браться из global environment. 


```{r}
f2_alt <- function (){
    x + 10e4
  }
f1_alt <- function(x) {
  f2_alt
}
f1_alt(100)()

```

2. Напишите функцию, принимающую на вход курс доллара и возвращающую другую функцию с одним числовым аргументом для конвертации суммы из рублей в доллары. Курс можно вводить произвольно.

```{r}
usd_convert <- function(usd) {
  convert <- function(amount) { #внутренняя функция для расчета курса доллара.
      output <- usd * amount
      return((output))
    }
  return(convert) #возвращает функцию с учтенным в этой функции значением параметра usd (подается на входе функции usd_convert)
}

USD_RUB_69 <- usd_convert(usd = 69) # создается новая функция с курсом 69

USD_RUB_69 (50) 

usd_convert(69)(50) #альтернативная записать той же функции.

```


3. Для проверки алгоритмов довольно часто бывают нужны синтетические данные, распределение которых не соответствует какому-либо простому закону (не является нормальным, равномерным и т.д.). Напишите функцию, генерирующую такие данные в виде числового вектора. В простейшем случае это может быть смесь нормальных распределений: итоговый вектор получается путем объединения результатов нескольких вызовов функции `rnorm()` с разными значениями `mean` и `sd`.
Вам пригодятся функции `Map()` или `purrr:map()`, а также `do.call`.

```{r}
#Установка пакетов, если отсутствуют:
#pacman::p_load(purrr)
#pacman::p_load(repurrrsive)
library(purrr)
library(repurrrsive)

noise_func <- function(len, min = 0, max = 1) {

  # случайным образом определяем количество отрезков, на котором будут генерироваться случайные числа.
  
  n_q <- sample(3:7, 1)   # случайным образом определяется количество отрезков
 
  
  #случайным образом определяем количество наблюдений на каждом отрезке (в сумме = количество генерируемых чисел)
  q_count <- (runif(n_q, 1.1, 4))^5     #за счет данной команды итоговое распределение должно быть менее похожим на равномерное
  freq <- round((q_count / sum(q_count))*len)       

  # вспомогательный код на случай, если из-за округления сумма не сойдется.
  i <- sample(n_q, 1)
  freq[i] <- freq[i] + (len - sum(freq))  #
  
  
  # определяем границы отрезков и параметры для генерации вектора с математическими ожиданиями
  q_len <- 100 / n_q
  mn <- list(n = freq, min = (q_len * 1:n_q - q_len), max = (q_len * 1:n_q)) %>%
    pmap(runif)  %>%   #лист с математическими ожиданиями для последующей генерации случайных значений
    unlist()
  mn <- mn[sample(len, len, replace = FALSE)]   # значения перемешиваются

  #создается список с аргументами для вызова функций rnorm:
  #Математическое ожидание распределено со случайной частотой на нескольких отрезках 
  #Вектор со значениями стандартных отклонений распределен нормально

  args <- list(n = c(rep(1, len)), mean = mn, sd = abs(rnorm(len, 10, 10)))
  
  #для вызова rnorm испльзуется фукнция pmap, так как на нее можно подать список с несколькими параметрами.
  #unlist список в вектор, abs убирает отрицательные значения.
  result <- pmap(args, rnorm) %>%
    unlist () %>%
    abs()
  
  #убираем значения, превышающие 100, для последующей "нормализации"
  z <- length(result[result > 100])
  result[result > 100] <- runif(z, min = 0, max = 100)
  
  #результат "нормализуется" с учетом заданных входных границ
  norm_result <- result / 100 * (max - min) + min 

  return(norm_result)
}
# на небольших выборках все же похоже на равномерное распределение, но иногда можно получить "выбросы", которые не появятся на равномерном распределении
test <- noise_func(200, 0, 5)
hist(test, breaks = c(0:5)) 

# для сравнения равномерное распределение
test_alt <- runif(200, 0, 5) 
hist(test_alt, breaks = c(0:5))

# на больших выборках меньше похоже на равномерное или случайное распределение
test2 <- noise_func(10000, -2, 2)
plot(sort(test2), type = "s") 
hist(test2)

```

___

# Комментарий к работе

Илья, спасибо за домашнюю работу! Задания выполнены, код функционирует.

Целью данного дз было опробовать на практике материал лекции: лексическую область видимости, попробовать написать замыкание, попользоваться `map()`. В работе всё это есть. 

По заданиям:

В **первой** задаче объяснение исчерпывающее, даже дополнительный пример есть. Всё отлично!

Код во **второй** задаче абсолютно корректен, работает как надо. Небольшая рекомендация по синтаксису: имеет смысл сразу писать `return(usd * amount)`. Это сократит количество кода и используемой в процессе памяти (не будет создана переменная `output`), улучшит читаемость (особенно актуально, когда в функциях много кода), а также повысит быстродействие. Можно убедиться, погоняв функции на `microbenchmark()`. К слову, быстрее всего работала бы функция даже без `return()`, но на мой взляд её лучше **всегда** писать в функциях, так как `return()` явно закончит вызов функции, да и просто так проще её читать. В остальном все отлично.

По **третьей** задаче - функция нетривиальная, интересная. Отмечу два важных момента: 
1) Лучше не использовать имя "c" или "T"/"F" или другое имя, принадлежащее функции или константному параметру, так как это может привести к некорректному поведению программы. Лучше давать имена подлинее и поподробнее (но без фанатизма).
2) Для проименованного списка внутри используется присвоение `=` , но не `<-`, то есть пишется `list(x = 2, y = "apple")`, как и в функциях. Можно проверить: в списке с созданием имен с таким синтаксисом имен не будет. Зато эти имена провалятся в .GlobalEnv и могут изменить существующие значения, что довольно критично. Если, конечно, есть цель создать переменные таким способом - то, можно, но я рекомендую это сделать вне `list()`.

```{r}
len <- 10
mn <- 5

# имен в списке нет
args <- list(n <- c(rep(1, len)), mean <- mn, sd <- abs(rnorm(len, 10, 10)))
names(args)

# а вот в глобальное окружение они попадают
ls(.GlobalEnv)
```

Полученный список `pmap()` всё равно переварит.

В данном кусочке (я подправил просвоение имен):

```{r}
args <- list(n = c(rep(1, len)), mean = mn, sd = abs(rnorm(len, 10, 10)))
  
  #для вызова rnorm испльзуется фукнция pmap, так как на нее можно подать список с несколькими параметрами.
  #unlist список в вектор, abs убирает отрицательные значения.
  result <- pmap(args, rnorm) %>%
    unlist () %>%
    abs()
```

в `n` будет вектор из 1. Так как `rnorm()` по умолчанию генерирует 1 значение, то я думаю, что в `n` нужды нет, и можно обойтись `map2()`, а если преобразовать данные в список параметров (т.е. не список из 1000 средних и 1000 ст. отклон, а 1000 пар среднее + ст. отлон.), то и просто `map()`. Возможно, будет немного быстрее, зависит от числа параметров.
В остальном с функцией всё в порядке. Может показаться, что в теле слишком много объявления новых переменных, и можно что-то сократить вложенными функциями и/или пайпингом, но, по моему мнению, в данном случае это не обязательно: используемые операции очень простые и выполняются быстро. Можно добиться небольшого (!) уменьшения объема используемой памяти, но вот насчет скорости - сомневаюсь.

Критерии оценивания:

 * Домашняя работа сдана (1/1 балл)
 * Решена 1 задача, описание подробное (1/1 балл)
 * Решена 2 задача (2/2 балла)
 * Решена 3 задача (3/3 балла)
 * Код оформлен согласно рекомендациям tidyverse (1 балл)
 * Задание сдано до рекомендуемого дедлайна (1/1 балл)
 * Задание сдано с 1 попытки (1/1 балл)
 
Задание считается выполненным, если набирается 6 баллов

**ИТОГО: `r 1+1+2+3+1+1+1` баллов**, домашняя работа принята! Если будут вопросы насчет альтернативной идеи для 3 задачи - пишите. 

Желаю дальнейших успехов в обучении!
