---
title: "hw_1_6"
output: html_document
---

1. Какой значение вернет следующая функция? Запишите ответ с пояснением почему, НЕ исполняя код функции.

Комментарии: 
Должно получиться 100100.
`x` во вложенной функции будет найден в функции `f1` (как ее параметр), так как будет рассматриваться как аргумент функции `f1`.
В связи с тем, что `x` будет найдено внутри функции `f1`, то за поиском не будет продолжаться на уровень выше - в global environment, т.е. `x <- 42` хоть и сохранит свое значение, но использоваться внутри формулы не будет.

```{r}
x <- 42
f1 <- function(x) {
  function() {
    x + 10e4
  }
}
f1(100)()


```
Проверьте себя, запустив данный фрагмент кода, и поясните результат.

Комментарии:

Приведенный выше пример демонстрирует лексическую область видимости (lexical scoping) в R. Так как `function()` определена внутри функции `f1(x)`, то и поиск `x` начнется в первую очередь там, где определена вложенная функция, - в `f1`.  

Особенности lexical scoping четко видно на другом примере, когда применяемая внутри функции `f1(x)` функция `f2() x + 10e4` изначально определена вне `f1(x)`.  Во втором случае, когда выполняется определенная в global environment `f2`  внутри `f1`, то результат будет иной, так как значение `x` будет браться из global environment. 


```{r}
f2_alt <- function (){
    x + 10e4
  }
f1_alt <- function(x) {
  f2_alt
}
f1_alt(100)()

```

2. Напишите функцию, принимающую на вход курс доллара и возвращающую другую функцию с одним числовым аргументом для конвертации суммы из рублей в доллары. Курс можно вводить произвольно.

```{r}
usd_convert <- function(usd) {
  convert <- function(amount) { #внутренняя функция для расчета курса доллара.
      output <- usd * amount
      return((output))
    }
  return(convert) #возвращает функцию с учтенным в этой функции значением параметра usd (подается на входе функции usd_convert)
}

USD_RUB_69 <- usd_convert(usd = 69) # создается новая функция с курсом 69

USD_RUB_69 (50) 

usd_convert(69)(50) #альтернативная записать той же функции.

```


3. Для проверки алгоритмов довольно часто бывают нужны синтетические данные, распределение которых не соответствует какому-либо простому закону (не является нормальным, равномерным и т.д.). Напишите функцию, генерирующую такие данные в виде числового вектора. В простейшем случае это может быть смесь нормальных распределений: итоговый вектор получается путем объединения результатов нескольких вызовов функции `rnorm()` с разными значениями `mean` и `sd`.
Вам пригодятся функции `Map()` или `purrr:map()`, а также `do.call`.

```{r}
#Установка пакетов, если отсутствуют:
#pacman::p_load(purrr)
#pacman::p_load(repurrrsive)
library(purrr)
library(repurrrsive)

noise_func <- function(len, min = 0, max = 1) {

  # случайным образом определяем количество отрезков, на котором будут генерироваться случайные числа.
  
  n_q <- sample(3:7, 1)   # случайным образом определяется количество отрезков
 
  
  #случайным образом определяем количество наблюдений на каждом отрезке (в сумме = количество генерируемых чисел)
  c <- (runif(n_q, 1.1, 4))^5     #за счет данной команды итоговое распределение должно быть менее похожим на равномерное
  freq <- round((c / sum(c))*len)       

  # вспомогательный код на случай, если из-за округления сумма не сойдется.
  i <- sample(n_q, 1)
  freq[i] <- freq[i] + (len - sum(freq))  #
  
  
  # определяем границы отрезков и параметры для генерации вектора с математическими ожиданиями
  q_len <- 100 / n_q
  mn <- list(n <- freq, min = (q_len * 1:n_q - q_len), max = (q_len * 1:n_q)) %>%
    pmap(runif)  %>%   #лист с математическими ожиданиями для последующей генерации случайных значений
    unlist()
  mn <- mn[sample(len, len, replace = FALSE)]   # значения перемешиваются

  #создается список с аргументами для вызова функций rnorm:
  #Математическое ожидание распределено со случайной частотой на нескольких отрезках 
  #Вектор со значениями стандартных отклонений распределен нормально

  args <- list(n <- c(rep(1, len)), mean <- mn, sd <- abs(rnorm(len, 10, 10)))
  
  #для вызова rnorm испльзуется фукнция pmap, так как на нее можно подать список с несколькими параметрами.
  #unlist список в вектор, abs убирает отрицательные значения.
  result <- pmap(args, rnorm) %>%
    unlist () %>%
    abs()
  
  #убираем значения, превышающие 100, для последующей "нормализации"
  z <- length(result[result > 100])
  result[result > 100] <- runif(z, min = 0, max = 100)
  
  #результат "нормализуется" с учетом заданных входных границ
  norm_result <- result / 100 * (max - min) + min 

  return(norm_result)
}
# не небольших выборках все же похоже на навномерное распределение, но иногда можно получить "выбросы", которые не появятся на равномерном распределении
test <- noise_func(200, 0, 5)
hist(test, breaks = c(0:5)) 

# для сравнения равномерное распределение
test_alt <- runif(200, 0, 5) 
hist(test_alt, breaks = c(0:5))

# на больших выборках меньше похоже на равномерное или случайное распределение
test2 <- noise_func(10000, -2, 2)
plot(sort(test2), type = "s") 


```

___

Критерии оценивания:

 * Домашняя работа сдана (1 балл)
 * Решена 1 задача, описание подробное (1 балл)
 * Решена 2 задача (2 балла)
 * Решена 3 задача (3 балла)
 * Код оформлен согласно рекомендациям tidyverse (1 балл)
 * Задание сдано до рекомендуемого дедлайна (1 балл)
 * Задание сдано с 1 попытки (1 балл)
 
Задание считается выполненным, если набирается 6 баллов
