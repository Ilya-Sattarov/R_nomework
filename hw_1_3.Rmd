---
title: "hw_1_3"
output: html_document
---

### Логические сравнения значений

1. Создайте сэмпл длиной в 10 элементов из встроенного в R вектора `month.name` и запишите в вектор `vec5`. Замените в векторе `vec5` 3 значение на `NA`, а пятое - на `""` (пустое значение). Выведите на печать вектор `vec5`.

```{r}
#решение
vec5 <- sample(month.name, 10)
vec5[3] <- NA
vec5[5] <- ""
print(vec5)

```

2. Напишите выражение, в котором используются логические сравнения (одно или несколько) и которое возвращает: только непропущенные значения вектора `vec5`; только непустые значения вектора `vec5`; только непустые и непропущенные значения вектора `vec5`.

```{r}
# первый вариант громоздкий, оставил как пример loop...
#только непропущенные значения вектора
#вариант 1
for (i in (seq_along(vec5))) {
       if (is.na(vec5[i]) == FALSE) {
               print (vec5[i])
       }
}
#вариант 2
vec5[!is.na(vec5)]

#только непустые значения вектора
#вариант 1
for (i in (seq_along(vec5))) {
       if (is.na(vec5[i]) == TRUE) {
               print (vec5[i])
       } else if (vec5[i] != "") {
               print (vec5[i])
       }
}
#вариант 2
vec5[vec5 != ""]

#только непустые и непропущенные значения вектора `vec5`
#вариант 1
for (i in (seq_along(vec5))) {
       if (is.na(vec5[i]) == FALSE)  {
               if (vec5[i] != "") {
                       print (vec5[i])
               }
        }
}
#вариант 2
vec5[(!is.na(vec5))&(vec5 != "")]

```


### Сравнение векторов

3. Создайте вектор `vec6 <- c('a', 'd', 'e', 'k')` и `vec7 <- c('a', 'g', 'd', 'k')`. Сравните вектор `vec6` с значением 'd' с помощью выражения `==`. Попробуйте вместо `==` использовать `=`. Понимаете ли вы, почему возникает ошибка?

```{r}
#решение
vec6 <- c('a', 'd', 'e', 'k')
vec7 <- c('a', 'g', 'd', 'k')

vec6 == "d"

vec6 = "d"

```


`==` - сравнивает значение и возвращает `TRUE` или `FALSE`

`=` - присваивает значение



4. Попробуйте сравнить вектор `vec6` с вектором c('d', 'e'). Понимаете ли вы, почему произошла ошибка? Попробуйте сравнить вектор `vec6` и вектор `vec7`. Почему это работает? Можно ли утверждать, что `vec6` и `vec7` имеют только два общих элемента?

```{r}
#решение
vec6 <- c('a', 'd', 'e', 'k') # возвращаем вектору 6 исходное значение
vec6 == c('d', 'e')
vec6 == vec7
```

Вектор `vec6` не сравнивается корректно с вектором `c('d', 'e')` из-за их разной длины.

При сравнении векторов `vec6` и `vec7`, имеющих одну длину, поочердено сравниваются соответствующие значения векторов.


5. С помощью функции `which()` определите номер элемента `vec6`, на котором стоит `'d'`. Аналогично для вектора `vec7`. Проверьте, что элементы векторов по этим номерам правда совпадают.

```{r}
#результат
which(vec6 == "d")
which(vec7 == "d")
which(vec6 == "d") == which(vec7 == "d")

```

Элемент `d` в векторе `vec6` второй по порядку, в `vec7` - третий. 2 не равно 3.


6. Воспользуйтесь оператором `%in%`, чтобы проверить, все ли элементы вектора `vec6` входят в вектор `vec7`. Какого типа будет результат проверки, и какой длины? Почему?

```{r}
#решение
vec6%in%vec7

```

Каждое значение вектора `vec6` по порядку проверяется на наличие среди значений вектора `vec7`. Длина получившегося логичесного вектора будет равна количеству элементов проверяемого вектора `vec6`. Длина `vec7` значения не имеет.


7. Извлеките те элементы вектора `vec6`, которые входят в вектор `vec7`. Извлеките те элементы вектора `vec6`, которые не входят в вектор `vec7` (подумайте, как корректно указать отрицание). 

```{r}
#решение
vec6%in%vec7
vec6[vec6%in%vec7]
vec6[!vec6%in%vec7]
```
### Логические ветвления

8. Выполните выражение `ifelse(3 != 4, "true", "wrong")`. Понимаете ли вы, как работает функция `ifelse()`? Поэкспериментируйте с разными вариантами логических проверок в `ifelse()`, и попробуйте объяснить результаты:

 - вместо 3 подставьте разные числа от 2 до 5;

 - попробуйте вместо логического выражения поставить `vec6 == 'd'`;
 
 - попробуйте вместо логического выражения поставить `vec6 == c('d', 'e')`;
 
 - попробуйте вместо логического выражения поставить `vec6 == vec7`;
 
 - попробуйте вместо логического выражения поставить `vec6 %in% vec7`;
 
 - попробуйте вместо логического выражения поставить `is.na(vec5)`.
 
```{r}
#решение
ifelse(3 != 4, "true", "wrong")

```

Функция `ifelse(a, b, c)` проверяет логическое выражение `a`, если оно `TRUE`, то возвращает значение `b`, в противном случае (`a == FALSE`) - `c`


### Подсчет значений по логическим условиям

9. Используя функцию `sum()` подсчитайте, сколько:

 - элементов совпадает попарно в векторах `vec6` и `vec7`;
 
 - сколько элементов вектора `vec6` присутствует в векторе `vec7`;
 
 - сколько пропущенных или пустых значений в векторе `vec5`;
 
 - сколько НЕ пропущенных и НЕ пустых значений в векторе `vec5`.

```{r}
#решение
sum(vec6==vec7)

sum (vec6%in%vec7)

sum ((is.na(vec5))|(vec5 == ""))

sum ((!is.na(vec5))&(vec5 != ""))
```
 
 
### Использование циклов и apply
 
10. Установите пакедж mlbench. 
Подгрузите набор данных  `BostonHousing` и с его помощью рассчитайте медианное значение `nox` для каждого уникального значения `rad` при помощи подходящей `apply`-функции. Сделайте то же самое, используя цикл.

```{r}
#решение
pacman::p_load(mlbench)
data(BostonHousing)
str(BostonHousing)

#apply

BostonHousing$rad <- as.factor(BostonHousing$rad)
is.factor(BostonHousing$rad)
(tapply(BostonHousing$nox, BostonHousing$rad, median))

#loop
rad_unique <- unique(BostonHousing$rad)
med_for_rad <- vector("numeric",length = length(rad_unique))
for (i in 1:length(rad_unique)) {
        el <- rad_unique[i]
        med = median(BostonHousing$nox[BostonHousing$rad == el], na.rm = FALSE)
        med_for_rad[i] <- med    
}
(med_result <- data.frame(BostonHousing_rad = rad_unique, median = med_for_rad))

```
